<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Merging vs. Rebasing</title>
</head>
<body>
    <h1>Merging vs. Rebasing</h1>
    <p>git rebase solves the same problem as git merge</p>
    <p>Both of these commands are designed to integrate changes from one branch into another branch—they just do it in very different ways.</p>
    <h1>Merge</h1>
    <p>+ Merging is nice because it’s a non-destructive operation. The existing branches are not changed in any way.</p>
    <p>- this also means that the feature branch will have an extraneous merge commit every time you need to incorporate upstream changes.</p>
    <p> If master is very active, this can pollute your feature branch’s history quite a bit.</p>
    <p>Hard for other developers to understand the history of the project.</p>
    <h1>Rebase</h1>
    <p>+Rebase moves the entire new branch to begin on the tip of the master branch, effectively incorporating all of the new commits in master.</p>
    <p>Rebasing re-writes the project history by creating brand new commits for each commit in the original branch.</p>
    <p>You get a much cleaner project history.</p>
    <div><ol>
       <li>It eliminates the unnecessary merge commits required by git merge.</li>
       <li>Rebasing also results in a perfectly linear project history</li>
    </ol></div>
    <p>- You must follow the Golden Rule of Rebasing, because re-writing project history can be potentially catastrophic for your collaboration workflow.</p>
    <p>The golden rule of git rebase is to never use it on public branches.</p>
    <p>- Rebasing loses the context provided by a merge commit—you can’t see when upstream changes were incorporated into the feature.</p>
    
    
</body>
</html>